"use client"
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getTrace: () => getTrace,
  getXRay: () => getXRay,
  useQuerySubscription: () => useQuerySubscription
});
module.exports = __toCommonJS(src_exports);

// src/get-trace.ts
var import_error_stack_parser = __toESM(require("error-stack-parser"));

// src/clean-stack.ts
var unrelatedFunctionName = "renderWithHooks";
var cleanStack = (stack) => {
  const firstUnrelatedIndex = stack.findIndex(
    (frame) => frame.functionName === unrelatedFunctionName
  );
  if (firstUnrelatedIndex !== -1) {
    return stack.slice(0, firstUnrelatedIndex);
  }
  return stack;
};

// src/constants.ts
var REFINE_PACKAGE_FILEPATH_REGEXP = process.env.NODE_ENV !== "development" ? /node_modules\/refinedev\/(.*?)\// : /\/refine\/packages\/(.*?)\//;

// src/is-refine-stack.ts
var isRefineStack = (filename) => {
  if (!filename)
    return false;
  const match = filename.match(REFINE_PACKAGE_FILEPATH_REGEXP);
  return !!match;
};

// src/get-package-name-from-filename.ts
var getPackageNameFromFilename = (filename) => {
  var _a;
  if (!filename)
    return;
  const match = filename.match(REFINE_PACKAGE_FILEPATH_REGEXP);
  const name = (_a = match == null ? void 0 : match.groups) == null ? void 0 : _a.name;
  if (!name)
    return;
  return `@refinedev/${name}`;
};

// src/get-trace.ts
function getTrace(excludeFromTrace) {
  if (process.env.NODE_ENV !== "development") {
    return [];
  }
  try {
    const error = new Error();
    const stack = import_error_stack_parser.default.parse(error);
    const clean = cleanStack(stack);
    const traces = clean.map(
      (frame) => ({
        file: frame.fileName,
        line: frame.lineNumber,
        column: frame.columnNumber,
        function: frame.functionName,
        isRefine: isRefineStack(frame.fileName),
        packageName: getPackageNameFromFilename(frame.fileName)
      })
    ).filter((trace) => trace.function).filter((trace) => !(excludeFromTrace == null ? void 0 : excludeFromTrace.includes(trace.function ?? "")));
    return traces.slice(1);
  } catch (error) {
    return [];
  }
}

// src/get-resource-path.ts
var import_devtools_shared = require("@refinedev/devtools-shared");
var getResourcePath = (hookName) => {
  if (import_devtools_shared.scopes[hookName] === "auth") {
    return null;
  }
  if (hookName === "useCan") {
    return "key[1]";
  }
  if (import_devtools_shared.scopes[hookName] === "audit-log") {
    if (hookName === "useLog") {
      return "variables.resource";
    }
    return "key[1]";
  }
  if (import_devtools_shared.scopes[hookName] === "data") {
    if (hookName === "useCustom" || hookName === "useCustomMutation") {
      return null;
    }
    switch (hookName) {
      case "useList":
      case "useInfiniteList":
      case "useOne":
      case "useMany":
        return "key[2]";
      case "useCreate":
      case "useCreateMany":
      case "useDelete":
      case "useDeleteMany":
      case "useUpdate":
      case "useUpdateMany":
        return "variables.resource";
    }
  }
  return null;
};

// src/get-xray.ts
function getXRay(hookName, resourceName, excludeFromTrace) {
  if (process.env.NODE_ENV !== "development") {
    return {
      hookName: "",
      trace: [],
      resourcePath: null
    };
  }
  const trace = getTrace(excludeFromTrace).slice(1);
  const resourcePath = getResourcePath(hookName);
  return {
    hookName,
    trace,
    resourcePath,
    resourceName
  };
}

// src/use-query-subscription.tsx
var import_devtools_shared3 = require("@refinedev/devtools-shared");
var import_react = __toESM(require("react"));

// src/listeners.ts
var import_devtools_shared2 = require("@refinedev/devtools-shared");

// src/create-identifier.ts
var createIdentifier = (key, trace) => {
  const simpleTrace = trace == null ? void 0 : trace.map(
    (t) => `${t.file}:${t.line}:${t.column}#${t.function}-${t.packageName}-${t.isRefine ? 1 : 0}`
  );
  const str = JSON.stringify([...key ?? [], ...simpleTrace ?? []]);
  return str;
};

// src/listeners.ts
var createMutationListener = (ws) => (mutation) => {
  var _a;
  if (!((_a = mutation == null ? void 0 : mutation.meta) == null ? void 0 : _a.trace))
    return;
  const meta = mutation == null ? void 0 : mutation.meta;
  new Promise((resolve) => {
    var _a2, _b;
    (0, import_devtools_shared2.send)(ws, import_devtools_shared2.DevtoolsEvent.ACTIVITY, {
      type: "mutation",
      identifier: createIdentifier(
        mutation == null ? void 0 : mutation.options.mutationKey,
        (_a2 = mutation == null ? void 0 : mutation.meta) == null ? void 0 : _a2.trace
      ),
      key: mutation == null ? void 0 : mutation.options.mutationKey,
      status: mutation == null ? void 0 : mutation.state.status,
      state: mutation == null ? void 0 : mutation.state,
      variables: (_b = mutation == null ? void 0 : mutation.state) == null ? void 0 : _b.variables,
      ...meta
    });
    resolve();
  });
};
var createQueryListener = (ws) => (query) => {
  var _a;
  if (!((_a = query == null ? void 0 : query.meta) == null ? void 0 : _a.trace))
    return;
  const meta = query == null ? void 0 : query.meta;
  new Promise((resolve) => {
    var _a2;
    (0, import_devtools_shared2.send)(ws, import_devtools_shared2.DevtoolsEvent.ACTIVITY, {
      type: "query",
      identifier: createIdentifier(query.queryKey, (_a2 = query.meta) == null ? void 0 : _a2.trace),
      key: query.queryKey,
      status: query.state.status,
      state: query.state,
      ...meta
    });
    resolve();
  });
};

// src/use-query-subscription.tsx
var empty = {};
var noop = () => empty;
var useQuerySubscription = process.env.NODE_ENV !== "development" ? noop : (queryClient) => {
  const { ws } = (0, import_react.useContext)(import_devtools_shared3.DevToolsContext);
  const queryCacheSubscription = import_react.default.useRef(noop);
  const mutationCacheSubscription = import_react.default.useRef(noop);
  import_react.default.useEffect(() => {
    if (!ws)
      return () => 0;
    const queryCache = queryClient.getQueryCache();
    const queryListener = createQueryListener(ws);
    queryCache.getAll().forEach(queryListener);
    queryCacheSubscription.current = queryCache.subscribe(
      ({ query, type }) => (type === "added" || type === "updated") && queryListener(query)
    );
    return () => {
      var _a;
      (_a = queryCacheSubscription.current) == null ? void 0 : _a.call(queryCacheSubscription);
    };
  }, [ws, queryClient]);
  import_react.default.useEffect(() => {
    if (!ws)
      return () => 0;
    const mutationCache = queryClient.getMutationCache();
    const mutationListener = createMutationListener(ws);
    mutationCache.getAll().forEach(mutationListener);
    mutationCacheSubscription.current = mutationCache.subscribe(
      ({ mutation, type }) => (type === "added" || type === "updated") && mutationListener(mutation)
    );
    return () => {
      var _a;
      (_a = mutationCacheSubscription.current) == null ? void 0 : _a.call(mutationCacheSubscription);
    };
  }, [ws, queryClient]);
  import_react.default.useEffect(() => {
    if (!ws)
      return () => 0;
    const cb = (0, import_devtools_shared3.receive)(
      ws,
      import_devtools_shared3.DevtoolsEvent.DEVTOOLS_INVALIDATE_QUERY_ACTION,
      ({ queryKey }) => {
        if (queryKey) {
          queryClient.invalidateQueries({ queryKey });
        }
      }
    );
    return cb;
  }, [ws, queryClient]);
  return {};
};
//# sourceMappingURL=index.cjs.map